#undef BREAK_FLASH    // < disable flash operations (simulate flash failure)
#undef SR_DEBUG       // < extra messages from the state recorder

#define STATEREC_LEN 128
const volatile uint8_t __attribute__ ((section (".infoB"))) staterec_arr[STATEREC_LEN];

enum {
    ST_EXIT,
    RADIO_INIT,
    RADIO_TX_B0,
    RADIO_TX_B1,
    SENSOR_INIT,
    SENSOR_READ,
    ACTUATE,
    NUM_STATES,
    ERASED = 0xff
};

uint8_t staterec_next; // < index of next free position in staterec_arr or -1
uint8_t staterec_prev; // < previous state
bool staterec_exited;  // < true if previous state was exited cleanly

/**
 * Read state records from flash.
 */
void staterec_read() {
    // Find index of next free byte and store as staterec_next.
    staterec_next = STATEREC_LEN;
    for (uint8_t i = 0; i < STATEREC_LEN; i++) {
        if (staterec_arr[i] == ERASED) {
            staterec_next = i;
            break;
        }
    }

#ifdef SR_DEBUG
    char buf[20];
    snprintf(buf, sizeof(buf), "next free %u\r\n", staterec_next);
    uart_write(buf, sizeof(buf));
#endif

    // If freshly erased, assume last exit was successful.
    if (staterec_next > 0)
        staterec_exited = (staterec_arr[staterec_next - 1] == ST_EXIT);
    else
        staterec_exited = true;

    // If freshly erased, can't tell what last state was.
    if (staterec_exited) {
        staterec_prev =
            (staterec_next - 2 >= 0) ? staterec_arr[staterec_next - 2] : ERASED;
    } else {
        staterec_prev =
            (staterec_next - 1 >= 0) ? staterec_arr[staterec_next - 1] : ERASED;
    }

    // Check if last recorded state is valid. Will occur after programming.
    if (staterec_prev == 0) {
        staterec_prev = ERASED;
    }
}

void staterec_write(uint8_t state) {
    // Check if erase is required.
    if (staterec_next == STATEREC_LEN) {
        check_power(true);
#ifndef BREAK_FLASH
        FlashCtl_eraseSegment((unsigned char*)staterec_arr);
#endif
        staterec_next = 0;
    }

    uint8_t* dst = (uint8_t*)&staterec_arr[staterec_next];
    check_power(true);
#ifndef BREAK_FLASH
    FlashCtl_write8(&state, dst, 1);
#endif
    if (*dst != state) {
        // TODO: flash readback failure
        char buf[30];
        snprintf(buf, sizeof(buf), "!! flash write %u failed !!\r\n", *dst);
        uart_write(buf, sizeof(buf));
    } else {
#ifdef SR_DEBUG
        char buf[20];
        snprintf(buf, sizeof(buf), "wrote %u to ind %u\r\n", state,
                 staterec_next);
        uart_write(buf, sizeof(buf));
#endif
        staterec_next += 1;
    }
}

/**
 * Record state entry in flash.
 */
void staterec_enter(uint8_t state) {
    staterec_write(state);
    staterec_prev = state;
    staterec_exited = false;
}

/**
 * Record exit from previously-entered state.
 */
void staterec_finish() {
    staterec_write(ST_EXIT);
    staterec_exited = true;
}

